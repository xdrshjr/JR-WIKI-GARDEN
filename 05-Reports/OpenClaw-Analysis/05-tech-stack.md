# 技术栈选型：为什么我们选择这些工具？

> "选择技术栈就像选择人生伴侣——没有完美的，只有最适合的。" —— 某位在凌晨三点还在调试依赖冲突的工程师

构建一个Agent网关系统，技术栈的选择直接决定了你能走多远。本文将坦诚地分享OpenClaw团队在关键决策点上的思考过程，包括那些"早知道就选另一个"的后悔时刻。

## TypeScript + Node.js：被误解的黄金搭档

让我们直面争议：为什么不是Python？毕竟，AI生态几乎被Python统治。

答案很简单：**我们不是在写模型训练代码，我们在写基础设施。**

当Agent需要同时处理WhatsApp的WebSocket连接、Telegram的HTTP轮询、以及本地浏览器的CDP调试协议时，Node.js的事件循环比Python的asyncio要成熟得多。更重要的是，我们面对的是大量I/O密集型操作——消息收发、网络请求、文件系统操作——这正是Node.js的舒适区。

TypeScript则给了我们静态类型检查的安全感，又不牺牲JavaScript的灵活性。我们的`tsconfig.json`配置了严格的类型检查，但一旦涉及到与各种第三方SDK的交互，我们又能在必要时优雅地退回到`any`。这种"严格但务实"的态度贯穿整个项目。

当然，代价也是真实的。Node.js的单线程模型意味着一个同步的CPU密集型操作就能阻塞整个事件循环。我们的解决方案？把那些真正耗时的任务（比如PDF解析、图片处理）扔到Docker沙箱里，让它们在隔离环境中慢慢折腾，主进程继续响应消息。

## WebSocket：实时通信的「老派浪漫」

在Server-Sent Events、HTTP/2推送、gRPC流等众多选择面前，我们选择了最「老派」的WebSocket。为什么？

**因为可靠。**

OpenClaw的核心是一个Gateway服务，它需要同时与多个客户端保持长连接：macOS应用、Web界面、命令行工具，以及运行在各种设备上的Node代理。WebSocket的简单性在这里是优势——它就是一个双向通信管道，没有gRPC的复杂proto定义，没有SSE的单向限制。

我们基于`ws`库构建了一套完整的客户端-服务器协议。每个消息帧都有明确的类型：`req`（请求）、`res`（响应）、`event`（服务器推送）。连接建立后，客户端发送`connect`请求完成握手，之后就可以调用各种方法（如`send`、`poll`、`agent`）并订阅事件（如`presence`、`tick`）。

这套协议的一个设计亮点是**心跳检测**。Gateway每30秒发送一个`tick`事件，客户端如果在两倍间隔内没有收到，就认为连接已死，主动断开并重连。这种"猜疑链"设计比TCP的keepalive更可靠，因为它检测的是应用层的健康状态，而不仅仅是网络连通性。

## TypeBox：类型系统的「单一真相源」

如果你维护过大型TypeScript项目，你一定经历过这种痛苦：类型定义、运行时验证、API文档，三者各自为政，改了一处忘改另一处。

TypeBox解决了这个问题。

我们用TypeBox定义Gateway协议的所有schema——从`ConnectParams`到`ChatMessage`，从请求参数到响应结构。这些schema同时服务于三个目的：

1. **编译时类型检查**：TypeScript从schema推断出类型，确保代码的类型安全
2. **运行时验证**：通过AJV编译schema，验证每个进出Gateway的消息
3. **跨语言生成**：自动生成JSON Schema和Swift模型，供macOS客户端使用

举个例子，当我们需要添加一个新的API方法时，只需要在`src/gateway/protocol/schema.ts`中添加TypeBox定义，然后运行`pnpm protocol:check`，一切就自动就绪了。没有手写验证代码，没有手动同步文档，没有"类型和实现对不上"的bug。

这种"写一次，到处用"的理念，是我们对抗技术债务的利器。

## Pi Agent Core：站在巨人的肩膀上

Agent运行时是整个系统的心脏。我们没有从零开始造轮子，而是选择了`@mariozechner/pi-agent-core`作为基础。

这个选择背后是务实的考量：Agent运行时需要处理工具调用、对话管理、上下文窗口、错误恢复等复杂逻辑，这些都是可以 commoditized 的通用能力。我们的核心竞争力在于**连接**——把Agent接入各种消息平台——而不是Agent本身。

Pi Agent Core提供了一套清晰的扩展点，让我们可以注入自定义的工具提供者、LLM客户端、和对话存储。我们的沙箱系统、浏览器控制、节点配对等功能，都是作为插件接入这个核心。

当然，依赖第三方核心也有风险。如果有一天Pi Agent Core的更新方向与我们的需求冲突，我们可能需要fork或者替换。但在项目的这个阶段，"借用"比"拥有"更明智。

## 通道SDK：拥抱生态，保持灵活

OpenClaw支持多种消息通道，每种都有官方的Node.js SDK。我们的选型策略是：**能用官方SDK就用官方SDK，除非它实在太烂。**

- **WhatsApp**：使用`@whiskeysockets/baileys`。这是一个社区维护的库，基于WhatsApp Web协议。它不是官方SDK，但是开源社区最好的选择。代价是WhatsApp可以随时更改协议，让我们 scrambling。

- **Telegram**：使用`grammy`。这是一个设计精良、文档完善的框架，支持Webhook和轮询两种模式，还有丰富的插件生态。`@grammyjs/runner`和`@grammyjs/transformer-throttler`让我们的消息发送既高效又不会触发速率限制。

- **Slack**：使用`@slack/bolt`。Slack的官方SDK，支持Socket Mode（WebSocket）和HTTP模式。Socket Mode特别适合我们的Gateway架构——不需要公网URL，只需要一个WebSocket连接。

- **Line**：使用`@line/bot-sdk`。Line的官方SDK，简单易用，但功能相对基础。

- **Discord**：使用`@buape/carbon`。这是一个相对较新的库，但我们选择它是因为它对Discord的新特性支持更好，而且API设计更符合现代TypeScript风格。

每个SDK都有自己的 quirks 和 rate limits。我们的Gateway层做了统一抽象，让上层代码不需要关心"这条消息是发给Telegram还是WhatsApp"。这种解耦让我们可以轻松添加新通道，或者替换现有实现。

## 安全与沙箱：不信任任何人

Agent系统天然具有危险性——它可能执行代码、访问文件、与外网通信。我们的安全设计基于一个原则：**最小权限 + 深度防御**。

**沙箱层**使用Docker容器隔离Agent执行环境。默认配置下，容器运行在只读root文件系统上，丢弃了所有Linux capabilities（除了绝对必要的），有严格的CPU、内存、PID限制。seccomp和AppArmor配置文件进一步限制了系统调用。

**审计层**记录了所有工具调用和外部访问。每个`exec`、`read`、`write`操作都会被记录，包括调用参数、执行结果、耗时。这些日志不仅用于安全审查，也用于调试和性能分析。

**策略层**允许为每个Agent配置不同的权限。有些Agent只能访问特定目录，有些可以执行任意命令，有些完全不能访问网络。这些策略在运行时动态解析，合并全局配置和Agent特定的覆盖。

最有趣的设计是**工具策略（Tool Policy）**。我们不仅限制Agent能做什么，还限制它*认为*自己能做什么。一个在沙箱中运行的Agent，它的工具列表里不会包含`browser`或`exec`，即使这些工具在全局可用。这种"能力隐藏"防止了Agent产生不切实际的期望，也简化了错误处理。

## 总结：没有银弹，只有权衡

回顾这些技术选择，没有一个是"完美"的。TypeScript给了我们类型安全，但也带来了构建复杂性。Docker沙箱提供了隔离，但也增加了资源开销。Pi Agent Core加速了开发，但也引入了外部依赖。

但这就是工程的本质——在约束条件下做出最优决策，并准备好在未来条件变化时重新评估。

OpenClaw的技术栈不是刻在石头上的。如果明天出现了一个更好的Agent运行时，或者Rust的异步生态突然变得对Node.js开发者友好了，我们会毫不犹豫地考虑迁移。但在当下，这套栈让我们能够快速迭代、可靠交付、并保持对代码的掌控感。

毕竟，技术栈是手段，不是目的。我们的目标是让Agent能够无缝地与人交流——无论他们使用什么平台。只要工具能帮助实现这个目标，它就是好工具。
